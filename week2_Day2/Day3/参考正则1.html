<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
    <script type="text/javascript">
        //正则大部分情况下都是用来处理和匹配字符串的
        /*var reg=/\d+/;//一个或多个连续的数字  正则是定义了规则(模式)
        var str1="asd123fgh456xcv789";
        var str2="asd";
        var str3="asd1";
        console.log(reg.test(str1));//true
        console.log(reg.test(str2));//false
        console.log(reg.test(str3));//true*/

        //\d是元字符 \w匹配常用的字符 \b .除回车之外的所有字符


        //+也是元字符(代表出现多少次 和他类似的还有*零次或者多次 ?零到1次 {n}匹配确定n次，{n,}至少匹配n次 {n,m}至少匹配n次最多匹配m次)
       /* var reg=/\d*/ ;/*
        console.log(reg.test(str2));//true
        reg=/\d{2}/;
        console.log(reg.test(str3));//false
        console.log(reg.test(str1));//true
        reg=/\d{2,4}/;
        console.log(reg.test(str3));//false*/

        //^后面的元字符出现在开始的位置  $表示出现在结尾位置
        //验证只包含数字的
//        var reg=/^\d+$/;
//        console.log(reg.test("123asd456"));//false
//        console.log(reg.test("123456"));//true

        //除了有\d这样的元字符，还可以有常用的字符当做元字符
        /*var reg=/^-\d+$/;
        reg=/^[-+]?\d+$/;//可以是-或者+
        reg=/^[-+]?[1-9]\d+$/;//第一个要是1-9的数字 记住只能识别一位 18是两个字符
        reg=/^[-+]?[0-9]\d*(\.\d+)?$/;//带小数点，但是小数点可能出现可能不出现所以需要加上()?，不能直接的用.,这个是一个也是意义的元字符，所以需要转义 ()中是一个单独的小的正则子正则
        console.log(reg.test("0.123456"));
        console.log(reg.test("-9.0"));

        // | 匹配两个 前后只要有一个匹配就好 、
        //^*/


       /* var reg=/\w+/ig;//匹配出现一个或者多个任意字符(包括下划线)[A-Za-z0-9]
        //i(忽略大小写) g(全部查找) m(多行查找不常用) 规则(模式)修正符
        var reg=new RegExp("\\w+","ig"); //new RegExp("\w+","ig");/w+/ig
        var reg=new RegExp("abcdef","ig");

        var str="0-9";
        new RegExp("["+str+"]+");// /[0-9]+/
        var reg=/[d]+/;//这个不可以使用变量*/


       /* //不仅可以匹配，而且还可以获取到
        var reg=/\d{2,5}/;
        var str="123a4567890";
        console.log(reg.exec(str));//["12345", index: 0, input: "1234567890"]

        //正则是贪婪的，如果否和条件的话，他是按照最多的找
        //解决的话需要这样做 在量词后面加上一个?就好了
        var reg=/\d{2,5}?/;
        var str="a1234567890";
        console.log(reg.exec(str));//["12", index: 1, input: "a1234567890"]*/


        /*var reg=/[a-z]+(\d+)[a-z]+/i; //(子正则 在匹配的时候不仅可以把大的返回，而且也可以把小的返回)
        var str="312asda4354dasd4324";
        console.log(reg.exec(str));//["asda4354dasd", "4354", index: 3, input: "312asda4354dasd4324"]

        //()不仅仅是子正则，很多时候还是优先级 (\.\d+)只是为了匹配小数点格式，不想查找出来
        var reg=/^[-+]?[0-9]\d*(\.\d+)?$/;
        console.log(reg.exec("21.324"));//["21.324", ".324", index: 0, input: "21.324"]
        reg=/^[-+]?[0-9]\d*(?:\.\d+)?$/;
        console.log(reg.exec("21.324"));//["21.324", index: 0, input: "21.324"]*/


        /*var reg=/^i come from china|america|france|german|canada$/;
        console.log(reg.exec("i come from france"));//["france", index: 12, input: "i come from france"]
        reg=/^i come from (china|america|france|german|canada)$/;
        console.log(reg.exec("i come from france"));//["i come from france", "france", index: 0, input: "i come from france"]
        reg=/^i come from (?:china|america|france|german|canada)$/;
        console.log(reg.exec("i come from france"));//["i come from france", index: 0, input: "i come from france"]*/

        //var reg=/[\u0000-\u007f]/;//基本上全了的字符  ASCII码表
        //var chineseReg=/^[^\u4e00-\u9fa5]+$/; 汉字的


        //边界 空格 连字符都是否和\b元字符的
        /*var str3="i come from australia one#two";
        var reg=/\b[a-z]+\b/g;
        var a=str3.match(reg);
        console.log(a);*/

        //分组引用
        /*var str="woow";//foof dood abba abca
        var reg=/^(\w)(\w)\2\1$/;//出现在第三个位置的要和第二个一样  出现在第四个位置的要和第一个样*/


    </script>
</body>
</html>